export function generateSetupScript(
	projectName: string,
	useWorkOS: boolean,
): string {
	return `#!/usr/bin/env bash
set -e

# =============================================================================
# Project Setup Script
# Generated by Hatch CLI
# =============================================================================

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
BLUE='\\033[0;34m'
NC='\\033[0m' # No Color

# Project configuration (embedded at generation time)
PROJECT_NAME="${projectName}"
USE_WORKOS=${useWorkOS ? "true" : "false"}

# State tracking file for idempotency
STATE_FILE=".setup-state"

# =============================================================================
# Helper Functions
# =============================================================================

print_header() {
  echo ""
  echo "========================================"
  echo -e "\${BLUE}\$1\${NC}"
  echo "========================================"
  echo ""
}

print_step() {
  echo -e "\${BLUE}→\${NC} \$1"
}

print_success() {
  echo -e "\${GREEN}✓\${NC} \$1"
}

print_warning() {
  echo -e "\${YELLOW}⚠\${NC} \$1"
}

print_error() {
  echo -e "\${RED}✗\${NC} \$1"
}

# State management for idempotency
mark_completed() {
  echo "\$1" >> "\$STATE_FILE"
}

is_completed() {
  [[ -f "\$STATE_FILE" ]] && grep -q "^\$1$" "\$STATE_FILE"
}

# Construct pooler DATABASE_URL from saved credentials (for runtime/serverless)
# Returns empty string if credentials not available
get_pooler_database_url() {
  local project_ref="\$1"

  if [[ ! -f ".supabase/.db-password" ]] || [[ ! -f ".supabase/.region" ]]; then
    echo ""
    return
  fi

  local db_password=\$(cat .supabase/.db-password)
  local region=\$(cat .supabase/.region)

  # Use transaction pooler (port 6543) for serverless compatibility
  echo "postgresql://postgres.\${project_ref}:\${db_password}@aws-0-\${region}.pooler.supabase.com:6543/postgres"
}

# Construct DATABASE_URL for DDL operations (migrations, schema push)
# Uses session pooler (aws-1, port 5432) which supports DDL and is IPv4 compatible
get_direct_database_url() {
  local project_ref="\$1"

  if [[ ! -f ".supabase/.db-password" ]] || [[ ! -f ".supabase/.region" ]]; then
    echo ""
    return
  fi

  local db_password=\$(cat .supabase/.db-password)
  local region=\$(cat .supabase/.region)

  # Use session pooler (aws-1, port 5432) for DDL operations
  # Note: aws-0 is transaction pooler (port 6543) which doesn't support DDL
  # Note: db.{ref}.supabase.co is IPv6-only and doesn't resolve on many networks
  echo "postgresql://postgres.\${project_ref}:\${db_password}@aws-1-\${region}.pooler.supabase.com:5432/postgres"
}

# =============================================================================
# Step 1: Check Prerequisites
# =============================================================================

check_prerequisites() {
  print_header "Checking Prerequisites"

  local missing=()

  # Check gh CLI
  if command -v gh &> /dev/null; then
    print_success "GitHub CLI (gh) installed"
  else
    missing+=("gh")
    print_error "GitHub CLI (gh) not installed"
  fi

  # Check vercel CLI
  if command -v vercel &> /dev/null; then
    print_success "Vercel CLI installed"
  else
    missing+=("vercel")
    print_error "Vercel CLI not installed"
  fi

  # Check supabase CLI
  if command -v supabase &> /dev/null; then
    print_success "Supabase CLI installed"
  else
    missing+=("supabase")
    print_error "Supabase CLI not installed"
  fi

  # Check jq (needed for parsing JSON)
  if command -v jq &> /dev/null; then
    print_success "jq installed"
  else
    missing+=("jq")
    print_error "jq not installed"
  fi

  if [[ \${#missing[@]} -gt 0 ]]; then
    echo ""
    print_error "Missing required tools: \${missing[*]}"
    echo ""
    echo "Install them with:"
    for tool in "\${missing[@]}"; do
      case \$tool in
        gh)
          echo "  brew install gh"
          ;;
        vercel)
          echo "  npm i -g vercel"
          ;;
        supabase)
          echo "  brew install supabase/tap/supabase"
          ;;
        jq)
          echo "  brew install jq"
          ;;
      esac
    done
    exit 1
  fi

  print_success "All prerequisites satisfied"
}

# =============================================================================
# Step 2: Authenticate with GitHub
# =============================================================================

auth_github() {
  print_header "GitHub Authentication"

  # Check if already authenticated
  if gh auth status &> /dev/null; then
    print_success "Already authenticated with GitHub"
    return 0
  fi

  print_step "Opening browser for GitHub authentication..."
  gh auth login --web

  if gh auth status &> /dev/null; then
    print_success "GitHub authentication successful"
  else
    print_error "GitHub authentication failed"
    exit 1
  fi
}

# =============================================================================
# Step 3: Authenticate with Supabase
# =============================================================================

auth_supabase() {
  print_header "Supabase Authentication"

  # Check if already authenticated
  if supabase projects list &> /dev/null 2>&1; then
    print_success "Already authenticated with Supabase"
    return 0
  fi

  print_step "Opening browser for Supabase authentication..."
  supabase login

  if supabase projects list &> /dev/null 2>&1; then
    print_success "Supabase authentication successful"
  else
    print_error "Supabase authentication failed"
    exit 1
  fi
}

# =============================================================================
# Step 4: Authenticate with Vercel
# =============================================================================

auth_vercel() {
  print_header "Vercel Authentication"

  # Check if already authenticated
  if vercel whoami &> /dev/null 2>&1; then
    print_success "Already authenticated with Vercel"
    return 0
  fi

  print_step "Opening browser for Vercel authentication..."
  vercel login

  if vercel whoami &> /dev/null 2>&1; then
    print_success "Vercel authentication successful"
  else
    print_error "Vercel authentication failed"
    exit 1
  fi
}

# =============================================================================
# Step 4b: Select Vercel Team/Account
# =============================================================================

select_vercel_team() {
  print_header "Vercel Team Selection"

  print_step "Select which Vercel account/team to use for this project..."
  echo ""

  # vercel switch without arguments shows interactive picker
  vercel switch

  # Show which team was selected
  local current_team=\$(vercel whoami 2>/dev/null)
  if [[ -n "\$current_team" ]]; then
    print_success "Using Vercel account: \$current_team"
  fi
}

# =============================================================================
# Step 5: Create GitHub Repository
# =============================================================================

create_github_repo() {
  print_header "GitHub Repository Setup"

  # Check if remote 'origin' already exists locally
  if git remote get-url origin &> /dev/null 2>&1; then
    print_success "Git remote 'origin' already configured"
    # Verify we can access the remote
    if git ls-remote origin &> /dev/null 2>&1; then
      print_success "Remote repository accessible"
    else
      print_warning "Remote exists but may not be accessible"
    fi
    return 0
  fi

  if is_completed "github_repo"; then
    print_success "GitHub repository already created (from previous run)"
    return 0
  fi

  # Check if repo already exists on GitHub before creating
  if gh repo view "\$PROJECT_NAME" &> /dev/null 2>&1; then
    print_warning "Repository '\$PROJECT_NAME' already exists on GitHub"
    echo ""
    echo "Options:"
    echo "  1. Link to existing repository (won't push - manual sync required)"
    echo "  2. Use a different name"
    echo "  3. Cancel setup"
    echo ""
    read -p "Choice (1/2/3): " choice

    case \$choice in
      1)
        # Link to existing - DO NOT push (would overwrite remote)
        local gh_user=\$(gh api user -q .login 2>/dev/null)
        git remote add origin "https://github.com/\$gh_user/\$PROJECT_NAME.git"
        print_success "Linked to existing repository"
        print_warning "Code NOT pushed to avoid overwriting. Sync manually if needed."
        mark_completed "github_repo"
        return 0
        ;;
      2)
        read -p "Enter new repository name: " new_name
        print_step "Creating private GitHub repository: \$new_name"
        if gh repo create "\$new_name" --private --source=. --push; then
          print_success "GitHub repository '\$new_name' created and code pushed"
          mark_completed "github_repo"
        else
          print_error "Failed to create repository"
          exit 1
        fi
        return 0
        ;;
      3)
        print_step "Cancelled by user"
        exit 1
        ;;
      *)
        print_error "Invalid choice"
        exit 1
        ;;
    esac
  fi

  # Safe to create - repo doesn't exist
  print_step "Creating private GitHub repository: \$PROJECT_NAME"

  if gh repo create "\$PROJECT_NAME" --private --source=. --push; then
    print_success "GitHub repository created and code pushed"
    mark_completed "github_repo"
  else
    print_error "Failed to create repository"
    echo ""
    echo "This might happen if:"
    echo "  - Repository name is already taken"
    echo "  - You don't have permission to create repos"
    echo ""
    read -p "Would you like to link to an existing repository? (y/N) " link_existing
    if [[ "\$link_existing" == [yY] ]]; then
      read -p "Enter repository (e.g., username/repo): " repo_name
      git remote add origin "https://github.com/\$repo_name.git"
      git push -u origin main 2>/dev/null || git push -u origin master 2>/dev/null || true
      mark_completed "github_repo"
    else
      exit 1
    fi
  fi
}

# =============================================================================
# Step 6: Create Supabase Project
# =============================================================================

create_supabase_project() {
  print_header "Supabase Project Setup"

  # Check if already linked
  if [[ -f ".supabase/.project-ref" ]]; then
    local existing_ref=\$(cat .supabase/.project-ref)
    print_success "Already linked to Supabase project: \$existing_ref"
    return 0
  fi

  if is_completed "supabase_project"; then
    print_success "Supabase project already configured (from previous run)"
    return 0
  fi

  # Check if project name already exists in user's Supabase account
  local existing_project=\$(supabase projects list -o json 2>/dev/null | jq -r ".[] | select(.name == \\"\$PROJECT_NAME\\") | .id" 2>/dev/null || echo "")

  if [[ -n "\$existing_project" ]]; then
    print_warning "Supabase project '\$PROJECT_NAME' already exists (ref: \$existing_project)"
    echo ""
    echo "Options:"
    echo "  1. Link to existing project"
    echo "  2. Create with different name"
    echo "  3. Cancel setup"
    echo ""
    read -p "Choice (1/2/3): " choice

    case \$choice in
      1)
        PROJECT_REF="\$existing_project"
        print_success "Using existing project: \$PROJECT_REF"
        ;;
      2)
        read -p "Enter new project name: " new_name
        create_new_supabase_project "\$new_name"
        return \$?
        ;;
      3)
        print_step "Cancelled by user"
        exit 1
        ;;
      *)
        print_error "Invalid choice"
        exit 1
        ;;
    esac
  else
    create_new_supabase_project "\$PROJECT_NAME"
  fi

  # Save project ref
  mkdir -p .supabase
  echo "\$PROJECT_REF" > .supabase/.project-ref

  mark_completed "supabase_project"
  print_success "Supabase project configured: \$PROJECT_REF"
}

create_new_supabase_project() {
  local proj_name="\$1"

  print_step "Creating new Supabase project: \$proj_name"

  # Get organization
  echo ""
  echo "Available organizations:"
  supabase orgs list
  echo ""
  read -p "Enter organization ID: " org_id

  if [[ -z "\$org_id" ]]; then
    print_error "Organization ID is required"
    exit 1
  fi

  # Generate a secure database password
  local db_password=\$(openssl rand -base64 24 | tr -dc 'a-zA-Z0-9' | head -c 20)

  # Create project interactively (lets CLI handle region selection)
  echo ""
  print_step "Creating project (this may take 1-2 minutes)..."
  echo ""
  echo "  The Supabase CLI will prompt you to select a region."
  echo ""

  # Run interactively - do NOT capture output or it breaks the region prompt
  if supabase projects create "\$proj_name" --org-id "\$org_id" --db-password "\$db_password"; then
    print_success "Supabase project created"

    # Save password for later DATABASE_URL construction
    mkdir -p .supabase
    echo "\$db_password" > .supabase/.db-password
    chmod 600 .supabase/.db-password

    # Look up the project reference and region
    print_step "Fetching project details..."

    local max_attempts=10
    local attempt=0

    while [[ \$attempt -lt \$max_attempts ]]; do
      attempt=\$((attempt + 1))
      echo "  Checking project status (attempt \$attempt/\$max_attempts)..."

      local project_info=\$(supabase projects list -o json 2>/dev/null | jq -r ".[] | select(.name == \\"\$proj_name\\")" 2>/dev/null || echo "")

      if [[ -n "\$project_info" ]]; then
        PROJECT_REF=\$(echo "\$project_info" | jq -r '.id')
        local region=\$(echo "\$project_info" | jq -r '.region')
        echo "\$region" > .supabase/.region
        print_success "Project is ready: \$PROJECT_REF (region: \$region)"
        break
      fi

      sleep 10
    done

    if [[ -z "\$PROJECT_REF" ]]; then
      print_warning "Could not automatically get project reference"
      echo ""
      echo "Please find your project reference at: https://supabase.com/dashboard"
      echo "Go to: Project Settings > General > Reference ID"
      read -p "Enter project reference: " PROJECT_REF
    fi
  else
    print_warning "Could not create project via CLI"
    echo ""
    echo "This can happen if:"
    echo "  - The Supabase CLI has issues fetching available regions"
    echo "  - Project name contains invalid characters (use lowercase, numbers, hyphens only)"
    echo "  - You've reached your project limit for this organization"
    echo ""
    echo "Let's create the project via the dashboard instead."
    echo ""

    # Open dashboard
    open "https://supabase.com/dashboard/new/\$org_id" 2>/dev/null || echo "  Open: https://supabase.com/dashboard/new/\$org_id"

    echo ""
    echo "  Steps:"
    echo "    1. Name your project: \$proj_name"
    echo "    2. Generate or enter a database password"
    echo "    3. Select a region close to your users"
    echo "    4. Click 'Create new project'"
    echo "    5. Wait for the project to be ready"
    echo "    6. Go to Project Settings > General > Reference ID"
    echo ""
    read -p "Enter the project reference ID: " PROJECT_REF
  fi

  if [[ -z "\$PROJECT_REF" ]]; then
    print_error "Project reference is required"
    exit 1
  fi
}

# =============================================================================
# Step 7: Link Supabase Project
# =============================================================================

link_supabase() {
  print_header "Linking Supabase Project"

  if [[ ! -f ".supabase/.project-ref" ]]; then
    print_error "No Supabase project configured"
    exit 1
  fi

  local project_ref=\$(cat .supabase/.project-ref)

  print_step "Linking to project: \$project_ref"
  supabase link --project-ref "\$project_ref"

  print_success "Supabase project linked"
}

# =============================================================================
# Step 8: Run Database Migrations
# =============================================================================

run_migrations() {
  print_header "Running Database Migrations"

  if [[ ! -f ".supabase/.project-ref" ]]; then
    print_error "No Supabase project configured"
    exit 1
  fi

  local project_ref=\$(cat .supabase/.project-ref)

  # Wait for database to be ACTIVE_HEALTHY
  print_step "Waiting for database to be ready..."
  local max_attempts=12
  local attempt=0

  while [[ \$attempt -lt \$max_attempts ]]; do
    attempt=\$((attempt + 1))
    local status=\$(supabase projects list -o json 2>/dev/null | jq -r ".[] | select(.id == \\"\$project_ref\\") | .status" 2>/dev/null || echo "")

    if [[ "\$status" == "ACTIVE_HEALTHY" ]]; then
      print_success "Database is ready"
      # Give pooler endpoints a moment to become fully available
      sleep 5
      break
    fi

    echo "  Waiting for database to provision (attempt \$attempt/\$max_attempts, status: \${status:-unknown})..."
    sleep 60
  done

  # Get direct DATABASE_URL for migrations (DDL requires direct connection, not pooler)
  local prod_db_url=\$(get_direct_database_url "\$project_ref")

  if [[ -z "\$prod_db_url" ]]; then
    print_warning "Database credentials not available - skipping migrations"
    echo "  You can run migrations manually later:"
    echo "  cd apps/web && pnpm db:generate"
    echo "  DATABASE_URL='your-url' pnpm db:migrate"
    echo ""
    echo "  Get your DATABASE_URL from:"
    echo "  https://supabase.com/dashboard/project/\$project_ref/settings/database"
    return 0
  fi

  cd apps/web

  # Generate initial migration files first
  print_step "Generating initial database migration..."
  if pnpm db:generate; then
    print_success "Initial migration generated"
  else
    echo ""
    print_warning "Could not generate migration - you may need to run: pnpm db:generate"
  fi

  # Run migrations (not db:push) so Drizzle records them as applied
  # This prevents "relation already exists" errors on deploy
  print_step "Applying migrations to production database..."
  if DATABASE_URL="\$prod_db_url" pnpm db:migrate; then
    print_success "Database migrations applied successfully"
  else
    echo ""
    print_warning "Migration failed - you may need to run it manually"
    echo "  cd apps/web && DATABASE_URL='<your-url>' pnpm db:migrate"
  fi
  cd ../..
}

# =============================================================================
# Step 9: Create/Link Vercel Project
# =============================================================================

setup_vercel() {
  print_header "Vercel Project Setup"

  # Check if already linked (in apps/web where the Next.js app lives)
  if [[ -f "apps/web/.vercel/project.json" ]]; then
    print_success "Already linked to a Vercel project"
    return 0
  fi

  if is_completed "vercel_project"; then
    print_success "Vercel project already configured (from previous run)"
    return 0
  fi

  print_step "Setting up Vercel project..."

  # Run vercel link with project name and --yes to skip prompts
  cd apps/web
  vercel link --project "\$PROJECT_NAME" --yes

  if [[ -f ".vercel/project.json" ]]; then
    print_success "Vercel project linked: \$PROJECT_NAME"

    # Set root directory via Vercel API (CLI doesn't support this)
    local project_id=\$(jq -r '.projectId' .vercel/project.json)
    local vercel_token=""

    # Try to get token from Vercel CLI config
    # macOS stores in Application Support, Linux in .config
    if [[ -f "\$HOME/Library/Application Support/com.vercel.cli/auth.json" ]]; then
      vercel_token=\$(jq -r '.token // empty' "\$HOME/Library/Application Support/com.vercel.cli/auth.json" 2>/dev/null)
    elif [[ -f "\$HOME/.config/com.vercel.cli/auth.json" ]]; then
      vercel_token=\$(jq -r '.token // empty' "\$HOME/.config/com.vercel.cli/auth.json" 2>/dev/null)
    fi

    if [[ -n "\$vercel_token" && -n "\$project_id" ]]; then
      print_step "Setting Vercel root directory to apps/web..."
      if curl -s -X PATCH "https://api.vercel.com/v9/projects/\$project_id" \\
        -H "Authorization: Bearer \$vercel_token" \\
        -H "Content-Type: application/json" \\
        -d '{"rootDirectory": "apps/web"}' > /dev/null; then
        print_success "Root directory configured"
      else
        print_warning "Could not set root directory - set it manually in Vercel dashboard"
      fi
    else
      print_warning "Could not set root directory automatically - set apps/web in Vercel dashboard"
    fi

    # Connect Git repository for automatic deployments
    local git_url=\$(git remote get-url origin 2>/dev/null || echo "")
    if [[ -n "\$git_url" ]]; then
      print_step "Connecting Git repository..."
      if vercel git connect "\$git_url" 2>/dev/null; then
        print_success "Git repository connected"
      else
        print_warning "Could not auto-connect Git - connect manually in Vercel dashboard"
      fi
    fi
    mark_completed "vercel_project"
  else
    print_warning "Vercel project may not be fully configured"
  fi

  cd ../..
}

# =============================================================================
# Step 9b: Configure Auth Secrets
# =============================================================================

setup_auth_secrets() {
  if [[ ! -f "apps/web/.vercel/project.json" ]]; then
    print_warning "Vercel project not linked, skipping auth secret setup"
    return 0
  fi

  if [[ "\$USE_WORKOS" == "true" ]]; then
    setup_workos_secrets
  else
    setup_better_auth_secrets
  fi
}

setup_better_auth_secrets() {
  print_header "Configuring Better Auth Secrets"

  print_step "Generating unique secrets for each environment..."

  local prod_secret=\$(openssl rand -base64 32)
  local preview_secret=\$(openssl rand -base64 32)
  local dev_secret=\$(openssl rand -base64 32)

  # Helper to set env var (removes existing first to avoid --force issues)
  set_vercel_env() {
    local name="\$1"
    local env="\$2"
    local value="\$3"
    local sensitive="\$4"

    # Remove existing var if present (ignore errors)
    vercel env rm "\$name" "\$env" --cwd apps/web --yes 2>/dev/null || true

    # Add the new value
    local flags=""
    if [[ "\$sensitive" == "true" ]]; then
      flags="--sensitive"
    fi
    printf '%s' "\$value" | vercel env add "\$name" "\$env" \$flags --cwd apps/web
  }

  # Add BETTER_AUTH_SECRET to each environment
  print_step "Adding BETTER_AUTH_SECRET to production..."
  if set_vercel_env "BETTER_AUTH_SECRET" "production" "\$prod_secret" "true" 2>/dev/null; then
    print_success "Production BETTER_AUTH_SECRET configured"
  else
    print_warning "Could not set production secret"
  fi

  print_step "Adding BETTER_AUTH_SECRET to preview..."
  if set_vercel_env "BETTER_AUTH_SECRET" "preview" "\$preview_secret" "true" 2>/dev/null; then
    print_success "Preview BETTER_AUTH_SECRET configured"
  else
    print_warning "Could not set preview secret"
  fi

  print_step "Adding BETTER_AUTH_SECRET to development..."
  # Note: Don't use --sensitive for development env vars
  if set_vercel_env "BETTER_AUTH_SECRET" "development" "\$dev_secret" "false" 2>/dev/null; then
    print_success "Development BETTER_AUTH_SECRET configured"
  else
    print_warning "Could not set development secret"
  fi

  # Add BETTER_AUTH_URL for production
  print_step "Adding BETTER_AUTH_URL to production..."
  if set_vercel_env "BETTER_AUTH_URL" "production" "https://\$PROJECT_NAME.vercel.app" "false" 2>/dev/null; then
    print_success "Production BETTER_AUTH_URL configured"
  else
    print_warning "Could not set production BETTER_AUTH_URL"
  fi

  print_step "Adding BETTER_AUTH_URL to development..."
  if set_vercel_env "BETTER_AUTH_URL" "development" "http://localhost:3000" "false" 2>/dev/null; then
    print_success "Development BETTER_AUTH_URL configured"
  else
    print_warning "Could not set development BETTER_AUTH_URL"
  fi

  # Note: Development secrets will be pulled to .env.local by pull_vercel_env()
  print_success "Better Auth secrets configured for all environments!"
}

setup_workos_secrets() {
  print_header "Configuring WorkOS Cookie Password"

  print_step "Generating unique secrets for each environment..."

  local prod_secret=\$(openssl rand -base64 32)
  local preview_secret=\$(openssl rand -base64 32)
  local dev_secret=\$(openssl rand -base64 32)

  # Helper to set env var (removes existing first to avoid --force issues)
  set_vercel_env() {
    local name="\$1"
    local env="\$2"
    local value="\$3"
    local sensitive="\$4"

    # Remove existing var if present (ignore errors)
    vercel env rm "\$name" "\$env" --cwd apps/web --yes 2>/dev/null || true

    # Add the new value
    local flags=""
    if [[ "\$sensitive" == "true" ]]; then
      flags="--sensitive"
    fi
    printf '%s' "\$value" | vercel env add "\$name" "\$env" \$flags --cwd apps/web
  }

  # Add WORKOS_COOKIE_PASSWORD to each environment
  print_step "Adding WORKOS_COOKIE_PASSWORD to production..."
  if set_vercel_env "WORKOS_COOKIE_PASSWORD" "production" "\$prod_secret" "true" 2>/dev/null; then
    print_success "Production WORKOS_COOKIE_PASSWORD configured"
  else
    print_warning "Could not set production secret"
  fi

  print_step "Adding WORKOS_COOKIE_PASSWORD to preview..."
  if set_vercel_env "WORKOS_COOKIE_PASSWORD" "preview" "\$preview_secret" "true" 2>/dev/null; then
    print_success "Preview WORKOS_COOKIE_PASSWORD configured"
  else
    print_warning "Could not set preview secret"
  fi

  print_step "Adding WORKOS_COOKIE_PASSWORD to development..."
  # Note: Don't use --sensitive for development env vars
  if set_vercel_env "WORKOS_COOKIE_PASSWORD" "development" "\$dev_secret" "false" 2>/dev/null; then
    print_success "Development WORKOS_COOKIE_PASSWORD configured"
  else
    print_warning "Could not set development secret"
  fi

  # Note: Development secrets will be pulled to .env.local by pull_vercel_env()
  print_success "WorkOS cookie password configured for all environments!"
}

# =============================================================================
# Step 10: Pull Vercel Environment Variables
# =============================================================================

pull_vercel_env() {
  print_header "Pulling Vercel Environment Variables"

  if [[ ! -f "apps/web/.vercel/project.json" ]]; then
    print_warning "Vercel project not linked, skipping env pull"
    return 0
  fi

  print_step "Pulling environment variables from Vercel..."

  # Pull to apps/web/.env.local (run from apps/web where .vercel config lives)
  cd apps/web
  vercel env pull .env.local --yes 2>/dev/null || true
  cd ../..

  print_success "Environment variables pulled (if any were configured in Vercel)"
}

# =============================================================================
# Step 11: Configure Database Environments
# =============================================================================

configure_database_environments() {
  print_header "Configuring Database Environments"

  if [[ ! -f ".supabase/.project-ref" ]]; then
    print_warning "No Supabase project configured, skipping"
    return 0
  fi

  local project_ref=\$(cat .supabase/.project-ref)
  local env_file="apps/web/.env.local"

  # Create env file from example if it doesn't exist
  if [[ ! -f "\$env_file" ]]; then
    if [[ -f "apps/web/.env.local.example" ]]; then
      cp "apps/web/.env.local.example" "\$env_file"
      print_step "Created .env.local from example"
    else
      touch "\$env_file"
    fi
  fi

  # -------------------------------------------------------------------------
  # Step 11a: Create Development Branches (dev, dev-test)
  # -------------------------------------------------------------------------
  print_step "Setting up database branches..."
  echo ""

  # Check if branching is enabled
  local branching_enabled=true
  if ! supabase branches list --project-ref "\$project_ref" &> /dev/null 2>&1; then
    print_warning "Branching not enabled for this project"
    echo ""
    echo "To enable branching (requires Pro plan):"
    echo "  https://supabase.com/dashboard/project/\$project_ref/settings/branching"
    echo ""
    read -p "Continue without branching? (y/N) " skip_branching
    if [[ "\$skip_branching" != [yY] ]]; then
      exit 1
    fi
    branching_enabled=false
  fi

  local dev_db_url=""
  local dev_test_db_url=""
  local preview_db_url=""

  if [[ "\$branching_enabled" == "true" ]]; then
    # Create dev branch
    echo "  Creating 'dev' branch (for local development)..."
    if supabase branches create dev --persistent --project-ref "\$project_ref" 2>/dev/null; then
      print_success "  dev branch created"
    else
      echo -e "    \${YELLOW}⚠ dev branch may already exist\${NC}"
    fi

    # Create dev-test branch
    echo "  Creating 'dev-test' branch (for local tests)..."
    if supabase branches create dev-test --persistent --project-ref "\$project_ref" 2>/dev/null; then
      print_success "  dev-test branch created"
    else
      echo -e "    \${YELLOW}⚠ dev-test branch may already exist\${NC}"
    fi

    # Note: Preview branches are created dynamically per PR via Supabase Vercel Integration

    # Wait for branches to provision
    echo ""
    print_step "Waiting for branches to provision (30 seconds)..."
    sleep 30

    # Fetch branch credentials
    print_step "Fetching branch credentials..."

    # Get dev branch URL
    if eval "\$(supabase branches get dev --project-ref "\$project_ref" -o env 2>/dev/null)"; then
      if [[ -n "\$POSTGRES_URL" ]]; then
        dev_db_url="\$POSTGRES_URL"
        print_success "  Got dev branch URL"
      fi
    fi

    # Get dev-test branch URL
    if eval "\$(supabase branches get dev-test --project-ref "\$project_ref" -o env 2>/dev/null)"; then
      if [[ -n "\$POSTGRES_URL" ]]; then
        dev_test_db_url="\$POSTGRES_URL"
        print_success "  Got dev-test branch URL"
      fi
    fi

    # Note: No need to run migrations on branches - they're copies of main
    # and already have the schema + migration history
    print_success "Branches created (schema inherited from main)"
  fi

  # -------------------------------------------------------------------------
  # Step 11b: Configure Vercel Production DATABASE_URL
  # -------------------------------------------------------------------------
  if [[ -f "apps/web/.vercel/project.json" ]]; then
    echo ""
    print_step "Configuring Vercel production DATABASE_URL..."

    # Use session pooler (aws-1, port 5432) which supports both:
    # - DDL operations (migrations) during build
    # - Runtime queries from serverless functions
    local prod_db_url=\$(get_direct_database_url "\$project_ref")

    if [[ -n "\$prod_db_url" ]]; then
      if printf '%s' "\$prod_db_url" | vercel env add DATABASE_URL production --cwd apps/web 2>/dev/null; then
        print_success "Production DATABASE_URL set in Vercel"
      else
        echo -e "  \${YELLOW}⚠ Could not set DATABASE_URL (may already exist)\${NC}"
      fi
    else
      print_warning "Could not get DATABASE_URL - add it manually in Vercel dashboard"
    fi
  fi

  # -------------------------------------------------------------------------
  # Step 11c: Setup Supabase Vercel Integration (optional)
  # -------------------------------------------------------------------------
  # The integration can handle preview branch DATABASE_URLs automatically
  if [[ "\$branching_enabled" == "true" ]] && [[ -f "apps/web/.vercel/project.json" ]]; then
    echo ""
    print_step "Supabase Vercel Integration Setup"
    echo ""
    echo "  The Supabase Vercel Integration automatically creates database branches"
    echo "  for each Vercel preview deployment. This requires connecting your"
    echo "  Supabase and Vercel accounts via the dashboard."
    echo ""
    read -p "  Open browser to set up integration now? (Y/n) " setup_integration
    setup_integration=\${setup_integration:-Y}

    if [[ "\$setup_integration" == [yY] ]]; then
      echo ""
      echo "  Opening Vercel projects page..."
      echo ""
      echo "  Steps to complete:"
      echo "    1. Select your project: \$PROJECT_NAME"
      echo "    2. Go to Settings → Integrations → Browse Marketplace"
      echo "    3. Find and add 'Supabase' integration"
      echo "    4. Connect to your existing Supabase project: \$project_ref"
      echo "    5. Enable 'Preview Branches' option"
      echo ""

      open "https://vercel.com/" 2>/dev/null || echo "  URL: https://vercel.com/"

      echo ""
      read -p "  Press Enter when you've completed the integration setup..." _
      print_success "Integration setup acknowledged"
    else
      echo ""
      print_step "Skipping integration setup"
      echo ""
      echo "  To set up later, go to your Vercel project:"
      echo "    Settings → Integrations → Browse Marketplace → Supabase"
      echo ""
      echo "  Or visit: https://vercel.com/integrations/supabase"
    fi
  fi

  # -------------------------------------------------------------------------
  # Step 11d: Configure Local .env.local
  # -------------------------------------------------------------------------
  echo ""
  print_step "Configuring local .env.local..."

  # Use dev branch URL for local development
  local local_db_url="\$dev_db_url"
  local local_test_db_url="\$dev_test_db_url"

  # If no branches, fall back to production URL for local dev
  if [[ -z "\$local_db_url" ]] && [[ "\$branching_enabled" != "true" ]]; then
    print_step "Using production database URL for local development..."
    # Use direct connection for local dev (allows running migrations locally)
    local_db_url=\$(get_direct_database_url "\$project_ref")
  fi

  if [[ -n "\$local_db_url" ]]; then
    update_env_var "\$env_file" "DATABASE_URL" "\$local_db_url"
    print_success "DATABASE_URL configured for local development"
  else
    print_warning "Could not configure DATABASE_URL - add it manually to .env.local"
  fi

  if [[ -n "\$local_test_db_url" ]]; then
    update_env_var "\$env_file" "TEST_DATABASE_URL" "\$local_test_db_url"
    print_success "TEST_DATABASE_URL configured for local tests"
  fi

  echo ""
  print_success "Database environments configured!"
  echo ""
  echo "  Production (Vercel):  DATABASE_URL configured"
  if [[ "\$branching_enabled" == "true" ]]; then
    echo "  Preview (Vercel):     Via Supabase Integration (if configured)"
    echo "  Development (local):  'dev' branch"
    echo "  Tests (local):        'dev-test' branch"
  else
    echo "  Development (local):  Main database (no branching)"
  fi
}

# Helper to update or add env var
update_env_var() {
  local file="\$1"
  local key="\$2"
  local value="\$3"

  if grep -q "^\$key=" "\$file" 2>/dev/null; then
    sed -i '' "s|^\$key=.*|\$key=\\"\$value\\"|" "\$file"
  else
    echo "\$key=\\"\$value\\"" >> "\$file"
  fi
}

# =============================================================================
# Step 12: Final Summary
# =============================================================================

print_summary() {
  print_header "Setup Complete!"

  echo "Your project has been configured with:"
  echo ""

  # GitHub status
  if git remote get-url origin &> /dev/null 2>&1; then
    local repo_url=\$(git remote get-url origin)
    echo -e "  \${GREEN}✓\${NC} GitHub: \$repo_url"
  fi

  # Vercel status
  if [[ -f "apps/web/.vercel/project.json" ]]; then
    echo -e "  \${GREEN}✓\${NC} Vercel: Project linked (apps/web)"
  fi

  # Supabase status
  if [[ -f ".supabase/.project-ref" ]]; then
    local project_ref=\$(cat .supabase/.project-ref)
    echo -e "  \${GREEN}✓\${NC} Supabase: \$project_ref"
  fi

  echo ""
  echo "Next steps:"
  echo ""
  echo "  1. Review apps/web/.env.local and fill in any missing values:"
  echo "     - RESEND_API_KEY (for email authentication)"
  echo "     - OPENAI_API_KEY or AI_GATEWAY_API_KEY"
  echo "     - NEXT_PUBLIC_POSTHOG_KEY (optional)"
  echo ""
  echo "  2. Start development:"
  echo "     pnpm dev"
  echo ""
  echo "  Vercel production DATABASE_URL has been configured."
  echo "  Add any additional env vars in the Vercel dashboard."
  echo ""
}

# =============================================================================
# Step 12: Install Claude Code Skills
# =============================================================================

install_skills() {
  print_header "Installing Claude Code Skills"

  print_step "Installing vercel-react-best-practices skill..."
  if npx -y skills add vercel-labs/agent-skills --skill vercel-react-best-practices --agent claude-code -y; then
    print_success "vercel-react-best-practices skill installed"
  else
    print_warning "Could not install vercel-react-best-practices skill"
  fi

  print_step "Installing agent-browser skill..."
  if npx -y skills add vercel-labs/agent-browser --skill agent-browser --agent claude-code -y; then
    print_success "agent-browser skill installed"
  else
    print_warning "Could not install agent-browser skill"
  fi
}

# =============================================================================
# Step 13: Commit Setup Changes and Deploy
# =============================================================================

commit_and_deploy() {
  print_header "Deploying to Production"

  # Check if there are any changes to commit (including untracked files)
  if [[ -z \$(git status --porcelain) ]]; then
    print_step "No setup changes to commit"
  else
    print_step "Committing setup changes..."
    git add -A
    git commit -m "chore: configure project setup

- Add Vercel project configuration
- Update .gitignore with Vercel entries
- Configure environment files" 2>/dev/null || true
  fi

  # Check if we need to push
  local unpushed=\$(git log origin/main..HEAD --oneline 2>/dev/null | wc -l | tr -d ' ')

  if [[ "\$unpushed" -gt 0 ]]; then
    echo ""
    read -p "Push to main and trigger production deploy? (Y/n) " do_deploy
    do_deploy=\${do_deploy:-Y}

    if [[ "\$do_deploy" == [yY] ]]; then
      print_step "Pushing to main..."
      if git push origin main; then
        print_success "Pushed to main - deployment triggered!"
      else
        print_warning "Push failed - deploy manually with: git push origin main"
      fi
    else
      print_step "Skipping deploy - deploy later with: git push origin main"
    fi
  else
    print_success "Already up to date with remote"
    echo ""
    echo "  No new commits to push, but you may still want to deploy."
    read -p "Trigger a production deployment via Vercel CLI? (Y/n) " do_cli_deploy
    do_cli_deploy=\${do_cli_deploy:-Y}

    if [[ "\$do_cli_deploy" == [yY] ]]; then
      print_step "Deploying to production..."
      if vercel --prod --yes; then
        print_success "Production deployment complete!"
      else
        print_warning "Deployment failed - try manually with: vercel --prod"
      fi
    else
      print_step "Skipping deploy - deploy later with: vercel --prod"
    fi
  fi
}

# =============================================================================
# Main Execution
# =============================================================================

main() {
  echo ""
  echo "========================================"
  echo "       \$PROJECT_NAME Setup"
  echo "========================================"
  echo ""
  echo "Mode: Supabase (cloud PostgreSQL)"
  echo ""

  check_prerequisites
  auth_github
  auth_supabase
  auth_vercel
  select_vercel_team
  create_github_repo
  create_supabase_project
  link_supabase
  run_migrations
  setup_vercel
  setup_auth_secrets
  pull_vercel_env
  configure_database_environments
  install_skills
  commit_and_deploy
  print_summary
}

# Run main function
main "\$@"
`;
}
